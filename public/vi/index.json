[
{
	"uri": "http://localhost:1313/internworkshop/vi/",
	"title": "API-First Development",
	"tags": [],
	"description": "",
	"content": "Phát triển API-First với OpenAPI và Code Generation Tổng quan Trong bài lab này, bạn sẽ tìm hiểu các khái niệm cơ bản và thực hành về API Gateway, Lambda function, CodeBuild và CodePipeline. Thực hành triển khai api với OpenAPI cũng như việc tự động hóa quá trình triển khai và kiểm tra code sau khi đẩy lên github.\nNội dung Giới thiệu Các bước chuẩn bị Tạo kết nối đến máy chủ EC2 API-First Development logs Port Forwarding Dọn dẹp tài nguyên "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/4-monitoring/4.1-configapigateway/",
	"title": "Cấu hình cho API Gateway",
	"tags": [],
	"description": "",
	"content": "Ở bước này, chúng ta sẽ cấu hình API Gateway để ghi log vào CloudWatch và bật X-Ray tracing. Việc này sẽ giúp chúng ta theo dõi các hoạt động của API và nhận được thông tin chi tiết về hiệu suất của nó.\nThiết lập API Gateway để ghi log vào CloudWatch Truy cập vào AWS Management Console và mở dịch vụ API Gateway.\nThêm Role cho API Gateway để có quyền ghi log vào CloudWatch. Bạn vào phần Settings của API Gateway, sau đó chọn Edit trong phần CloudWatch Logs. Chọn hoặc tạo một IAM Role có quyền ghi log vào CloudWatch. Ở đây mình tạo 1 role mới với tên là APIGatewayCloudWatchLogsRole và gán policy AmazonAPIGatewayPushToCloudWatchLogs.\nChọn API mà bạn muốn cấu hình.\nTrong phần Stages, chọn stage mà bạn muốn bật ghi log. Ở đây, stage của mình hiện tại là \u0026ldquo;dev\u0026rdquo;, bạn có thể chọn stage khác nếu cần.\nTrong phần Logs and tracing bạn nhấn vào edit để cấu hình. Ở đây mình sẽ chỉ bật các tùy chọn sau: CloudWatch Logs: Errors and Info logs X-Ray Tracing: Bật X-Ray tracing Lưu các thay đổi. Sau khi cấu hình xong, API Gateway sẽ bắt đầu ghi lại các log vào CloudWatch Logs. Bạn có thể kiểm tra các log này trong dịch vụ CloudWatch Logs. Thiết lập alarms cho API Gateway Truy cập vào AWS Management Console và mở dịch vụ CloudWatch. Trong phần Alarms, chọn Create Alarm. Chọn Select metric và tìm kiếm các metric liên quan đến API Gateway. Chọn các metric mà bạn muốn theo dõi và nhấn Select metric. Chọn API Gateway sau đó chọn By API Name để xem các metric liên quan đến API của bạn. Đây là 2 metric mình sử dụng để theo dõi: Latency: Thời gian phản hồi của API 5XXError: Số lượng lỗi 5xx (server errors) vì mỗi alarm sẽ theo dõi một metric, nên bạn cần tạo 2 alarm riêng biệt cho 2 metric này. Đầu tiên, bạn sẽ tạo alarm cho metric Latency:\nChọn metric Latency và nhấn Select metric. Đặt tên cho alarm, ví dụ: \u0026ldquo;User service latency alarm\u0026rdquo;. Statistic: Chọn Average. Period: Chọn khoảng thời gian mà bạn muốn theo dõi, ví dụ: 1 phút. Chọn Threshold type là Static. Chọn Whenever latency is và đặt ngưỡng (threshold) cho alarm. Thiết lập ngưỡng (threshold) cho alarm. Ví dụ, nếu bạn muốn nhận cảnh báo khi thời gian phản hồi vượt quá 1 giây, bạn có thể đặt ngưỡng là 1000 ms. Chọn Next để tiếp tục. Trong phần Configure actions, bạn có thể chọn các hành động khi alarm được kích hoạt, ví dụ: gửi email thông báo, các hành động khi alarm được kích hoạt. Chọn Next để tiếp tục. Trong phần Add name and description, bạn có thể đặt tên và mô tả cho alarm. Nhập tên cho alarm, ví dụ: User service latency alarm. Chọn Next để tiếp tục. Trong phần Review, kiểm tra lại các thiết lập của alarm và nhấn Create alarm để hoàn tất. Tương tự, bạn sẽ tạo alarm cho metric 5XXError:\nChọn metric 5XXError và nhấn Select metric. Đặt tên cho alarm, ví dụ: \u0026ldquo;User service 5XX error alarm\u0026rdquo;. Statistic: Chọn Sum. Period: Chọn khoảng thời gian mà bạn muốn theo dõi, ví dụ: 1 phút. Chọn Threshold type là Static. Chọn Whenever 5XXError is và đặt ngưỡng (threshold) cho alarm. Thiết lập ngưỡng (threshold) cho alarm. Ví dụ, nếu bạn muốn nhận cảnh báo khi số lượng lỗi 5xx vượt quá 5 trong 1 phút, bạn có thể đặt ngưỡng là 5. Lặp lại các bước cấu hình tương tự như trên để hoàn tất việc tạo alarm cho metric 5XXError. Sau khi cấu hình xong, bạn sẽ nhận được thông báo khi có sự cố xảy ra với API Gateway. "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/4-monitoring/4.2-configlambda/",
	"title": "Cấu hình cho Lambda",
	"tags": [],
	"description": "",
	"content": "Ở bước này, chúng ta sẽ cấu hình Lambda để ghi log vào CloudWatch và bật X-Ray tracing. Việc này sẽ giúp chúng ta theo dõi các hoạt động của Lambda và nhận được thông tin chi tiết về hiệu suất của nó.\nThiết lập Lambda để ghi log vào CloudWatch Truy cập vào AWS Management Console và mở dịch vụ Lambda. Chọn Lambda function mà bạn muốn cấu hình. Trong phần Configuration, chọn Monitoring and operations tools. Bật Active tracing để kích hoạt X-Ray tracing. Lưu các thay đổi. Sau khi cấu hình xong, Lambda sẽ bắt đầu ghi lại các log vào CloudWatch Logs. Bạn có thể kiểm tra các log này trong dịch vụ CloudWatch Logs.\nỞ đây, chúng ta sẽ cấu hình các Lambda functions để ghi log vào CloudWatch Logs. Mặc định, các Lambda functions đã được cấu hình để ghi log vào CloudWatch, nhưng bạn có thể tùy chỉnh thêm nếu cần.\nBạn chỉ cần đảm bảo rằng các Lambda functions của bạn có quyền ghi log vào CloudWatch. Điều này thường được thực hiện thông qua IAM Role mà bạn gán cho Lambda functions đã thực hiện ở bước Tạo Lambda function\nKiểm tra nhanh IAM Role của Lambda function:\nTruy cập vào AWS Management Console và mở dịch vụ IAM. Tìm kiếm và chọn IAM Role mà bạn đã gán cho Lambda function. Trong phần Permissions, đảm bảo rằng IAM Role này có policy AWSLambdaBasicExecutionRole hoặc tương tự để cho phép ghi log vào CloudWatch. Hoặc tại phần Configuration của Lambda function, bạn có thể thấy phần Execution role sau đó truy cập vào role đó và xem đã có policy AWSLambdaBasicExecutionRole chưa.\nThiết lập X-Ray tracing cho Lambda Trong phần Configuration của Lambda function, chọn Monitoring and operations tools. Trong phần X-Ray, bạn sẽ thấy tùy chọn để bật X-Ray tracing. Bật Active tracing để kích hoạt X-Ray tracing. Lưu các thay đổi. Sau khi bật X-Ray tracing, Lambda sẽ gửi dữ liệu tracing đến AWS X-Ray. Bạn có thể kiểm tra các trace này trong dịch vụ AWS X-Ray để theo dõi hiệu suất và các vấn đề của Lambda function. "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/2-prerequiste/2.1-createdynamodb/",
	"title": "Chuẩn bị bảng DynamoDB",
	"tags": [],
	"description": "",
	"content": "Tạo DynamoDB Table Trước tiên, chúng ta cần tạo cơ sở dữ liệu để lưu trữ thông tin người dùng. DynamoDB là lựa chọn tối ưu cho serverless architecture vì nó có khả năng scale tự động và tích hợp tốt với Lambda.\nTrong bước này, chúng ta sẽ cần tạo một bảng DynamoDB tên là Users , với Partition key là userID (String)\nCác bước bạn cần hoàn tất bước này sẽ như sau:\nVào DynamoDB Console Nhấn Create table Table name: Users Partition key: userID (String) Nhấn Create table Vào DynamoDB Console: Truy cập vào AWS Management Console và tìm kiếm DynamoDB. Nhấn Create table: Tại trang DynamoDB, bạn sẽ thấy nút \u0026ldquo;Create table\u0026rdquo; ở góc trên bên phải. Điền thông tin bảng: Nhập tên bảng là Users và Partition key là userID với kiểu dữ liệu là String. Các thông số khác có thể để mặc định. Cuối cùng, nhấn Create table để hoàn tất. Sau khi tạo bảng, bạn sẽ thấy bảng Users trong danh sách các bảng DynamoDB của bạn. Bạn có thể nhấn vào tên bảng để xem chi tiết và quản lý dữ liệu trong bảng này. "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Trong thời đại phát triển phần mềm hiện đại, việc thiết kế và phát triển API không chỉ còn là một bước phụ mà đã trở thành trọng tâm trong quy trình phát triển ứng dụng. Với phương pháp API-First Development, toàn bộ hệ thống được xây dựng xoay quanh các đặc tả API (API specifications), đảm bảo tính nhất quán, khả năng tái sử dụng và tốc độ phát triển vượt trội.\nĐề tài này triển khai một nền tảng API-First hoàn chỉnh trên AWS, kết hợp các công cụ và dịch vụ hiện đại như:\nOpenAPI Specification: Chuẩn hóa thiết kế API ngay từ đầu. Code Generation: Tự động sinh code server và client từ file OpenAPI. AWS Lambda \u0026amp; API Gateway: Triển khai API không máy chủ (serverless). DynamoDB: Lưu trữ dữ liệu theo mô hình NoSQL, hiệu quả và mở rộng tốt. CodePipeline \u0026amp; CodeBuild: Tự động hóa toàn bộ quy trình CI/CD. Jest \u0026amp; Coverage: Đảm bảo chất lượng bằng kiểm thử tự động và đo độ bao phủ mã. Redoc: Tạo tài liệu API đẹp mắt, tự động từ file OpenAPI. Mục tiêu Xây dựng một workflow phát triển API hiện đại với:\nThiết kế API trước (API-first) Sinh mã nguồn tự động Tích hợp kiểm thử và tài liệu hoá Tự động hoá triển khai trên AWS Lý do chọn đề tài Giảm thời gian phát triển và bảo trì API đến 70% Giải quyết vấn đề inconsistency giữa code và tài liệu Tạo ra một nền tảng dễ mở rộng, có thể tái sử dụng trong nhiều dự án "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/3-deploycodebuild/3.1-creategithubrepo/",
	"title": "Tạo GitHub Repository",
	"tags": [],
	"description": "",
	"content": "Tạo GitHub Repository Trong bước này, chúng ta sẽ tạo một repository trên GitHub để lưu trữ mã nguồn cho dự án của mình.\nCác bước bạn cần thực hiện như sau:\nTruy cập vào GitHub và đăng nhập vào tài khoản của bạn. Nhấn vào nút New ở góc trên bên trái để tạo một repository mới. Nhập thông tin cho repository: Repository name: UserService Description: API for User Service Visibility: Chọn Public hoặc Private tùy thuộc vào nhu cầu của bạn. Initialize this repository with: Bỏ chọn các tùy chọn như Add a README file, Add .gitignore, và Choose a license để bắt đầu với một repository trống. Nhấn Create repository để hoàn tất việc tạo repository. Sau khi tạo xong, bạn sẽ được chuyển đến trang quản lý của repository. Tại đây, bạn có thể thêm mã nguồn, tài liệu và cấu hình cho dự án của mình. Clone repository về máy tính của bạn để bắt đầu làm việc với mã nguồn. Bạn có thể sử dụng lệnh sau trong terminal:\ngit clone https://github.com/your-username/UserService.git cd UserService Tạo file frontend Để tạo một ứng dụng frontend đơn giản, bạn có thể sử dụng React. Bạn cần cài đặt Node.js và npm (Node Package Manager) trên máy tính của mình trước khi thực hiện bước này. Nếu bạn chưa cài đặt Node.js, bạn có thể tải xuống và cài đặt từ trang web chính thức của Node.js. Và npm sẽ được cài đặt cùng với Node.js. Sau khi cài đặt Node.js và npm, bạn có thể tạo một ứng dụng React mới bằng cách sử dụng Create React App, một công cụ tạo ứng dụng React nhanh chóng và dễ dàng. Để tạo ứng dụng React, bạn có thể sử dụng lệnh sau trong terminal:\nnpx create-react-app frontend --template typescript cd frontend Sẽ mất một chút thời gian để Create React App tạo ra cấu trúc thư mục và các file cần thiết cho ứng dụng React của bạn. Cấu trúc thư mục sau khi tạo sẽ như sau:\nUserService/ └── frontend/ ├── node_modules/ ├── public/ ├── src/ ├── ... ├── package.json └── README.md Sau khi tạo ứng dụng, cài đặt thêm các thư viện cần thiết cho việc gọi API và kiểm thử:\nnpm install axios npm install --save-dev jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom Quay lại thư mục gốc\ncd .. Tạo file generate-simple-tests.js Để tự động tạo các file test Jest đơn giản dựa trên API được tạo từ OpenAPI specification, bạn cần tạo một script Node.js có tên generate-simple-tests.js trong thư mục gốc của dự án.\nTạo file generate-simple-tests.js trong thư mục UserService với nội dung sau:\nconst fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); // Path to api.ts file const apiFilePath = path.join(__dirname, \u0026#39;frontend\u0026#39;, \u0026#39;src\u0026#39;, \u0026#39;api\u0026#39;, \u0026#39;api.ts\u0026#39;); // Path to save test files const parentDir = path.dirname(path.dirname(apiFilePath)); const outputDir = path.join(parentDir, \u0026#39;testapi\u0026#39;); if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true }); // Read api.ts content let apiContent; try { apiContent = fs.readFileSync(apiFilePath, \u0026#39;utf-8\u0026#39;); console.log(\u0026#39;Successfully read api.ts\u0026#39;); } catch (error) { console.error(\u0026#39;Cannot read api.ts file:\u0026#39;, error.message); process.exit(1); } // Find API methods in api.ts const methodRegex = /async\\s+(\\w+)\\s*\\([^)]*\\)\\s*:\\s*Promise\u0026lt;[^\u0026gt;]+\u0026gt;/g; const methods = []; let match; while ((match = methodRegex.exec(apiContent)) !== null) { methods.push({ name: match[1], fullMatch: match[0] }); } if (methods.length === 0) { console.log(\u0026#39;No API methods found in api.ts\u0026#39;); process.exit(1); } console.log(`Found ${methods.length} API methods`); // Map HTTP methods based on method name function guessHttpMethod(methodName) { if (methodName.startsWith(\u0026#39;get\u0026#39;)) return \u0026#39;get\u0026#39;; if (methodName.startsWith(\u0026#39;create\u0026#39;) || methodName.startsWith(\u0026#39;add\u0026#39;) || methodName.startsWith(\u0026#39;post\u0026#39;)) return \u0026#39;post\u0026#39;; if (methodName.startsWith(\u0026#39;update\u0026#39;) || methodName.startsWith(\u0026#39;edit\u0026#39;) || methodName.startsWith(\u0026#39;put\u0026#39;)) return \u0026#39;put\u0026#39;; if (methodName.startsWith(\u0026#39;delete\u0026#39;) || methodName.startsWith(\u0026#39;remove\u0026#39;)) return \u0026#39;delete\u0026#39;; if (methodName.startsWith(\u0026#39;patch\u0026#39;)) return \u0026#39;patch\u0026#39;; return \u0026#39;get\u0026#39;; // Default to GET } // Create test file for each API method methods.forEach(method =\u0026gt; { const methodName = method.name; const httpMethod = guessHttpMethod(methodName); const endpoint = `/${methodName.replace(/^(get|create|update|delete|patch)/, \u0026#39;\u0026#39;).toLowerCase()}`; console.log(`Creating test for method: ${methodName}`); const testCode = ` describe(\u0026#39;${httpMethod.toUpperCase()} ${endpoint}\u0026#39;, () =\u0026gt; { it(\u0026#39;should call ${methodName} successfully\u0026#39;, () =\u0026gt; { // Simple passing test expect(true).toBe(true); }); });`.trim(); const testFilePath = path.join(outputDir, `${methodName}.test.js`); // Using .js instead of .ts try { fs.writeFileSync(testFilePath, testCode); console.log(`Created: ${methodName}.test.js`); } catch (error) { console.error(`Cannot create test file for ${methodName}:`, error.message); } }); console.log(\u0026#39;All test files have been created.\u0026#39;); Tạo file buildspec.yml File buildspec.yml là file cấu hình cho AWS CodeBuild, nó định nghĩa các bước cần thực hiện để xây dựng và triển khai ứng dụng của bạn. Bạn cần tạo file này trong thư mục gốc của repository.\nNội dung của file buildspec.yml như sau:\nversion: 0.2 cache: paths: - \u0026#39;frontend/node_modules/**/*\u0026#39; phases: install: runtime-versions: nodejs: 18 commands: - echo Installing dependencies... - npm install -g @openapitools/openapi-generator-cli - cd frontend - npm install - npm install --save-dev jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom - npm install -g jest - cd .. pre_build: commands: - echo Writing setupTests.js... - mkdir -p frontend/src - | cat \u0026lt;\u0026lt;EOF \u0026gt; frontend/src/setupTests.js // Jest setup file // Using require instead of import for compatibility require(\u0026#39;@testing-library/jest-dom\u0026#39;); EOF - echo Writing jest.config.js... - | cat \u0026lt;\u0026lt;EOF \u0026gt; frontend/jest.config.js module.exports = { testEnvironment: \u0026#39;jsdom\u0026#39;, setupFilesAfterEnv: [\u0026#39;\u0026lt;rootDir\u0026gt;/src/setupTests.js\u0026#39;], moduleFileExtensions: [\u0026#39;js\u0026#39;, \u0026#39;jsx\u0026#39;, \u0026#39;ts\u0026#39;, \u0026#39;tsx\u0026#39;, \u0026#39;json\u0026#39;], testMatch: [\u0026#39;**/testapi/*.test.js\u0026#39;, \u0026#39;**/__tests__/**/*.test.js\u0026#39;], collectCoverage: true, coverageDirectory: \u0026#39;coverage\u0026#39;, testPathIgnorePatterns: [\u0026#39;/node_modules/\u0026#39;] }; EOF - echo Export OpenAPI spec from API Gateway... - aws apigateway get-export --rest-api-id $API_ID --stage-name $STAGE --export-type oas30 --accepts application/json openapi.json - | if [ ! -f openapi.json ]; then echo \u0026#34;Error: Failed to export openapi.json\u0026#34; exit 1 fi - echo Generating TypeScript Axios client from OpenAPI spec... - openapi-generator-cli generate -i openapi.json -g typescript-axios -o frontend/src/api - echo Generating Jest test files from API... - node generate-simple-tests.js build: commands: - echo Running frontend tests with coverage... - cd frontend - CI=true npm test -- --passWithNoTests || echo \u0026#34;Tests failed but continuing build\u0026#34; - echo Build frontend app... - npm run build - cd .. artifacts: files: - frontend/build/**/* - frontend/coverage/**/* Và cấu trúc thư mục của bạn sẽ trông như sau:\nUserService/\r├── frontend/\r│ ├── node_modules/\r│ ├── public/\r│ ├── src/\r│ │ ├── testapi/ (sẽ được tạo bởi generate-simple-tests.js)\r│ │ ├── api/ (sẽ được tạo bởi openapi-generator-cli)\r│ │ ├── ...\r│ ├── package.json\r│ ├── jest.config.js (sẽ được tạo trong quá trình build)\r│ ├── ...\r├── generate-simple-tests.js\r└── buildspec.yml Cuối cùng, bạn cần commit và push các thay đổi lên GitHub:\ngit add . git commit -m \u0026#34;Add frontend React app, generate-simple-tests.js, and buildspec.yml\u0026#34; git push origin main Sau khi push thành công, bạn có thể kiểm tra lại repository trên GitHub để đảm bảo rằng các file đã được cập nhật đúng cách.\n"
},
{
	"uri": "http://localhost:1313/internworkshop/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "\rBạn cần tạo sẵn 1 bảng DynamoDB, 1 Lambda function và 1 API Gateway để thực hiện bài thực hành này.\nKiến trúc đơn giản DynamoDB: Lưu trữ dữ liệu người dùng Lambda Function: Xử lý CRUD operations API Gateway: REST API endpoints Sau đây là các bước tạo DynamoDB, Lambda và API Gateway\nNội dung Tạo bảng trong DynamoDB Tạo Lambda function Tạo API Gateway "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/3-deploycodebuild/3.2-createcodebuild/",
	"title": "Tạo dịch vụ CodeBuild",
	"tags": [],
	"description": "",
	"content": "Ở bước này, bạn sẽ tạo một dự án CodeBuild để biên dịch mã nguồn của bạn. Dự án này sẽ sử dụng tệp cấu hình buildspec.yml để xác định các bước cần thực hiện trong quá trình biên dịch.\nTạo dự án CodeBuild Vào CodeBuild Console. Nhấp vào nút Create project. Nhập tên cho dự án của bạn, ví dụ: UserServiceBuild. Chọn Source provider là GitHub hoặc GitHub Enterprise tùy thuộc vào nơi lưu trữ mã nguồn của bạn. Kết nối tài khoản GitHub của bạn nếu chưa làm. Chọn kho lưu trữ chứa mã nguồn của bạn. Trong phần Environment, chọn Managed image và chọn hệ điều hành và runtime phù hợp với dự án của bạn, ví dụ: Ubuntu và Standard. Trong phần Buildspec, chọn Use the buildspec.yml file để sử dụng tệp cấu hình buildspec.yml đã có trong kho lưu trữ của bạn. Trong phần Artifacts, chọn No artifacts nếu bạn không cần lưu trữ kết quả biên dịch, hoặc chọn Amazon S3 nếu bạn muốn lưu trữ kết quả biên dịch trong một bucket S3. Nhấn Create build project để hoàn tất. Vào CodeBuild Console: Truy cập vào AWS Management Console và tìm kiếm CodeBuild. Tiếp tục, bạn sẽ thấy trang CodeBuild. Nhấn Create project để bắt đầu tạo dự án mới. Cấu hình dự án CodeBuild Trong phần cấu hình dự án, bạn sẽ cần cung cấp các thông tin sau:\nProject name: Nhập tên cho dự án của bạn, ví dụ: UserServiceBuild.\nSource provider: Chọn GitHub hoặc GitHub Enterprise tùy thuộc vào nơi lưu trữ mã nguồn của bạn.\nRepository: Chọn kho lưu trữ chứa mã nguồn của bạn. Environment: Chọn Managed image và chọn hệ điều hành và runtime phù hợp với dự án của bạn, ví dụ: Ubuntu và Standard. Trong phần Additional configuration của Environment, bạn thêm các biến môi trường như sau: Chú ý: Thay API_ID bằng ID API của bạn, STAGE là giai đoạn bạn muốn triển khai trong API Gateway (ví dụ: \u0026ldquo;prod\u0026rdquo; hoặc \u0026ldquo;dev\u0026rdquo;)\nService role: Chọn New service role để tạo một vai trò dịch vụ mới cho CodeBuild hoặc chọn một vai trò đã có nếu bạn đã tạo trước đó. Mình sẽ để mặc định là New service role. Buildspec: Chọn Use the buildspec.yml file để sử dụng tệp cấu hình buildspec.yml đã có trong kho lưu trữ của bạn. Các phần còn lại như Artifacts và Logs có thể để mặc định hoặc tùy chỉnh theo nhu cầu của bạn. Ở đây mình sẽ để mặc định. Nhấn Create build project để hoàn tất việc tạo dự án. Vậy là bạn đã tạo xong dự án CodeBuild. Bây giờ, bạn có thể chạy dự án này để biên dịch mã nguồn của mình.\nThêm role IAM cho CodeBuild Để CodeBuild có thể truy cập vào các dịch vụ AWS khác như S3, API Gateway, bạn cần cấp quyền cho vai trò IAM mà CodeBuild sử dụng. Bạn có thể làm theo các bước sau:\nVào IAM Console. Chọn Roles từ menu bên trái. Tìm kiếm vai trò mà CodeBuild đã tạo (nó thường có tên dạng codebuild-\u0026lt;project-name\u0026gt;-service-role). Nhấp vào vai trò đó để xem chi tiết. Trong phần Permissions, nhấp vào Add permissions và chọn Create policy. Chọn JSON và dán vào đoạn mã sau để cấp quyền truy cập vào S3 và API Gateway: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;apigateway:GET\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:apigateway:region-id::/restapis/api-id/stages/stage-name/exports/*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::codebuild-[region-id]-[aws-account-id]/*\u0026#34; } ] } Ở đây mình thêm quyền truy cập vào API Gateway và S3. Bạn cần thay thế region-id, api-id, stage-name, và aws-account-id bằng các giá trị tương ứng của bạn. 7. Nhấn Review policy, đặt tên cho policy này (ví dụ: CodeBuildUserServicePolicy), và nhấn Create policy. 8. Quay lại vai trò IAM mà bạn đã chọn, nhấp vào Attach policies và tìm kiếm policy vừa tạo. 9. Chọn policy đó và nhấn Attach policy để gán quyền cho vai trò.\nChạy dự án CodeBuild Bây giờ bạn đã tạo xong dự án CodeBuild và gán quyền cho vai trò IAM, bạn có thể chạy dự án này để biên dịch mã nguồn của mình.\nVào CodeBuild Console. Chọn dự án UserServiceBuild mà bạn đã tạo. Nhấn nút Start build để bắt đầu quá trình biên dịch. Bạn có thể theo dõi quá trình biên dịch trong tab Builds. Nếu quá trình biên dịch thành công, bạn sẽ thấy trạng thái là SUCCEEDED. Đây là giao diện của CodeBuild khi bạn chạy thành công dự án: "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/2-prerequiste/2.2-createlambda/",
	"title": "Tạo Lambda Function",
	"tags": [],
	"description": "",
	"content": "1: Tạo Lambda Function Trong bước này, chúng ta sẽ tạo một Lambda function để xử lý các yêu cầu từ API Gateway. Lambda function này sẽ thực hiện các thao tác CRUD (Create, Read, Update, Delete) trên bảng DynamoDB mà chúng ta đã tạo ở bước trước. Vì để đơn giản nên chúng ta dùng 1 Lambda function duy nhất để xử lý tất cả các yêu cầu CRUD. Các bạn có thể tạo nhiều Lambda function khác nhau cho từng thao tác CRUD nếu muốn.\nCác bước bạn cần hoàn tất bước này sẽ như sau:\nVào Lambda Console Nhấn Create function Function name: UserService Runtime: Node.js 18.x Nhấn Create function Vào Lambda Console: Truy cập vào AWS Management Console và tìm kiếm Lambda. Nhấn Create function: Tại trang Lambda, bạn sẽ thấy nút \u0026ldquo;Create function\u0026rdquo; ở góc trên bên phải. Điền thông tin function: Nhập tên function là UserService, chọn Runtime là Node.js 18.x. Các thông số khác có thể để mặc định. Cuối cùng, nhấn Create function để hoàn tất.\nỞ đây chúng ta sử dụng Node.js làm ngôn ngữ lập trình cho Lambda function. Bạn có thể chọn ngôn ngữ khác nếu muốn, nhưng cần đảm bảo rằng mã nguồn của bạn tương thích với runtime đó.\nVà vì trước đó mình đã tạo 1 lambda function với tên là UserService nên mình sẽ ghi thành UserService1 để tránh trùng tên. Còn nếu bạn chưa tạo thì có thể để tên là UserService.\nNgoài thông tin về tên và runtime, bạn có thể để các thông số khác mặc định. Sau khi nhấn Create function, Lambda sẽ tạo function cho bạn. Role IAM sẽ được tạo tự động để cho phép Lambda truy cập vào các dịch vụ AWS khác như DynamoDB.\nNhấn Create function: Sau khi điền đầy đủ thông tin, nhấn nút \u0026ldquo;Create function\u0026rdquo; để hoàn tất việc tạo Lambda function. Sau khi tạo function, bạn sẽ thấy trang quản lý của Lambda function UserService. Tại đây, bạn có thể cấu hình các thông số khác như quyền truy cập, biến môi trường, và mã nguồn của function. 2: Tải mã nguồn cho Lambda Function Bây giờ chúng ta sẽ tải mã nguồn cho Lambda function UserService. Mã nguồn này sẽ bao gồm các hàm để xử lý các yêu cầu CRUD từ API Gateway và tương tác với DynamoDB.\nBạn có thể tải mã nguồn trực tiếp lên Lambda hoặc sử dụng AWS CLI hoặc AWS SDK để tải mã nguồn từ máy tính của bạn lên Lambda.\nĐể đơn giản, chúng ta sẽ thêm mã nguồn trực tiếp lên Lambda.\nTrong trang quản lý Lambda function UserService, ở tab \u0026ldquo;Code\u0026rdquo;, bạn sẽ thấy một trình soạn thảo mã nguồn. Sao chép và dán mã nguồn sau vào trình soạn thảo: const { DynamoDBClient } = require(\u0026#39;@aws-sdk/client-dynamodb\u0026#39;); const { DynamoDBDocumentClient, ScanCommand, GetCommand, PutCommand, UpdateCommand, DeleteCommand } = require(\u0026#39;@aws-sdk/lib-dynamodb\u0026#39;); const { randomUUID } = require(\u0026#39;crypto\u0026#39;); const client = new DynamoDBClient({}); const dynamodb = DynamoDBDocumentClient.from(client); const TABLE_NAME = \u0026#39;Users\u0026#39;; exports.handler = async (event) =\u0026gt; { console.log(\u0026#34;Event Received:\u0026#34;, { resource: event.resource, path: event.path, pathParameters: event.pathParameters, }); const { httpMethod, pathParameters, body, resource } = event; try { switch (httpMethod) { case \u0026#39;GET\u0026#39;: if (resource === \u0026#39;/v1/users\u0026#39;) { return await getAllUsers(); } else if (resource === \u0026#39;/v1/users/{userID}\u0026#39; \u0026amp;\u0026amp; pathParameters?.userID) { return await getUserById(pathParameters.userID); } break; case \u0026#39;POST\u0026#39;: if (resource === \u0026#39;/v1/users\u0026#39;) { return await createUser(JSON.parse(body)); } break; case \u0026#39;PUT\u0026#39;: if (resource === \u0026#39;/v1/users/{userID}\u0026#39; \u0026amp;\u0026amp; pathParameters?.userID) { return await updateUser(pathParameters.userID, JSON.parse(body)); } break; case \u0026#39;DELETE\u0026#39;: if (resource === \u0026#39;/v1/users/{userID}\u0026#39; \u0026amp;\u0026amp; pathParameters?.userID) { return await deleteUser(pathParameters.userID); } break; } return { statusCode: 404, body: JSON.stringify({ message: \u0026#39;Not Found\u0026#39; }) }; } catch (error) { console.error(\u0026#34;Lambda Error:\u0026#34;, { message: error.message, stack: error.stack }); return { statusCode: 500, body: JSON.stringify({ message: error.message || \u0026#39;Internal server error\u0026#39; }) }; } }; // ========== DynamoDB Functions ========== async function getAllUsers() { const result = await dynamodb.send(new ScanCommand({ TableName: TABLE_NAME })); return { statusCode: 200, body: JSON.stringify(result.Items) }; } async function getUserById(userID) { const result = await dynamodb.send(new GetCommand({ TableName: TABLE_NAME, Key: { userID } })); if (!result.Item) { return { statusCode: 404, body: JSON.stringify({ message: \u0026#39;User not found\u0026#39; }) }; } return { statusCode: 200, body: JSON.stringify(result.Item) }; } async function createUser(userData) { const userID = randomUUID(); const user = { userID, ...userData }; await dynamodb.send(new PutCommand({ TableName: TABLE_NAME, Item: user })); return { statusCode: 201, body: JSON.stringify(user) }; } async function updateUser(userID, userData) { const updateExpression = []; const expressionAttributeValues = {}; const expressionAttributeNames = {}; Object.keys(userData).forEach(key =\u0026gt; { updateExpression.push(`#${key} = :${key}`); expressionAttributeValues[`:${key}`] = userData[key]; expressionAttributeNames[`#${key}`] = key; }); try { const result = await dynamodb.send(new UpdateCommand({ TableName: TABLE_NAME, Key: { userID }, UpdateExpression: `SET ${updateExpression.join(\u0026#39;, \u0026#39;)}`, ExpressionAttributeValues: expressionAttributeValues, ExpressionAttributeNames: expressionAttributeNames, ConditionExpression: \u0026#39;attribute_exists(userID)\u0026#39;, ReturnValues: \u0026#39;ALL_NEW\u0026#39; })); return { statusCode: 200, body: JSON.stringify(result.Attributes) }; } catch (error) { if (error.name === \u0026#39;ConditionalCheckFailedException\u0026#39;) { return { statusCode: 404, body: JSON.stringify({ message: \u0026#39;User not found\u0026#39; }) }; } throw error; } } async function deleteUser(userID) { await dynamodb.send(new DeleteCommand({ TableName: TABLE_NAME, Key: { userID } })); return { statusCode: 204, body: \u0026#39;\u0026#39; }; } khi bạn vừa thêm mã nguồn mới, Lambda sẽ thông báo rằng mã nguồn đã được thay đổi và yêu cầu bạn lưu lại. Đảm bảo file mã nguồn này được lưu với tên index.js trong thư mục gốc của Lambda function. Lambda sẽ tự động sử dụng file này làm entry point cho function.\n3. Nhấn Deploy để lưu thay đổi. Ở bước này mình thêm /v1/users vào đầu các đường dẫn để dễ dàng quản lý và mở rộng API trong tương lai. Bạn có thể thay đổi đường dẫn này nếu muốn, nhưng hãy nhớ cập nhật lại trong mã nguồn và cấu hình API Gateway sau này.\n3: Cấp quyền truy cập DynamoDB cho Lambda Function Để Lambda function có thể truy cập vào bảng DynamoDB, chúng ta cần cấp quyền truy cập cho Lambda function này. Điều này được thực hiện thông qua IAM Role mà Lambda function sử dụng.\nTrong trang quản lý Lambda function UserService, vào tag \u0026ldquo;Configuration\u0026rdquo;, vào tag \u0026ldquo;Permissions\u0026rdquo;, cuộn xuống phần \u0026ldquo;Execution role\u0026rdquo;.\nNhấn vào liên kết IAM role ở phần \u0026ldquo;role name\u0026rdquo; để mở trang quản lý IAM role. Trong trang IAM role, nhấn Add permissions và chọn Attach policies. Tìm kiếm và chọn chính sách AmazonDynamoDBFullAccess để cấp quyền truy cập đầy đủ vào DynamoDB. Bạn cũng có thể tạo một chính sách tùy chỉnh nếu muốn giới hạn quyền truy cập. Nhấn Attach policy để áp dụng chính sách này cho IAM role của Lambda function. Quay lại trang quản lý Lambda function, bạn sẽ thấy IAM role đã được cập nhật với chính sách mới. "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/2-prerequiste/2.3-createapigateway/",
	"title": "Tạo API Gateway",
	"tags": [],
	"description": "",
	"content": "Tạo API Gateway Trong bước này, chúng ta sẽ tạo một API Gateway để kết nối với Lambda function và DynamoDB. API Gateway sẽ cung cấp các endpoint để thực hiện các thao tác CRUD trên bảng DynamoDB thông qua Lambda function.\nCác bước bạn cần hoàn tất bước này sẽ như sau:\nVào API Gateway Console Nhấn Create API Chọn REST API và nhấn Build Nhập thông tin cho API: API name: UserServiceAPI Description: API for User Service Endpoint Type: Regional Nhấn Create API để hoàn tất việc tạo API Gateway. Vào API Gateway Console: Truy cập vào AWS Management Console và tìm kiếm API Gateway. Nhấn Create API: Tại trang API Gateway, bạn sẽ thấy nút \u0026ldquo;Create API\u0026rdquo; ở góc trên bên phải. Chọn REST API: Chọn tùy chọn \u0026ldquo;REST API\u0026rdquo; và nhấn nút \u0026ldquo;Build\u0026rdquo; để bắt đầu tạo API. Chọn New API: Chọn tùy chọn \u0026ldquo;New API\u0026rdquo; để tạo một API mới. Điền thông tin API: Nhập tên API là UserServiceAPI, mô tả là API for User Service, và chọn loại endpoint là Regional. Các thông số khác có thể để mặc định. Cuối cùng, nhấn Create API để hoàn tất. Tạo Resource và Method cho API Sau khi tạo API, bạn sẽ thấy trang quản lý của API Gateway UserServiceAPI. Tại đây, bạn có thể cấu hình các endpoint, phương thức HTTP, và tích hợp với Lambda function. Chọn Create Resource: Để tạo một resource cho API, bạn cần nhấn nút \u0026ldquo;Create Resource\u0026rdquo; trong trang quản lý API. Vì chúng ta sẽ tạo một resource cho người dùng, nên bạn có thể đặt tên resource là users hoặc v1/users để phân biệt với các phiên bản API khác trong tương lai. Ở đây, mình sẽ tạo resource là v1/users để phù hợp với phiên bản API. Đầu tiên, bạn cần tạo một resource chính cho API. Resource này sẽ là điểm gốc cho các endpoint của API.\nĐiền thông tin resource: Nhập tên resource là v1 và nhấn Create Resource để tạo resource này. Tương tự như v1 ta sẽ tạo một resource con là users trong resource v1. Chọn Create Method: Sau khi tạo resource v1/users, bạn cần tạo các phương thức HTTP cho resource này. Nhấn nút \u0026ldquo;Create Method\u0026rdquo; để bắt đầu. Chọn phương thức HTTP: Chọn phương thức HTTP mà bạn muốn tạo cho resource v1/users. Ví dụ, bạn có thể chọn GET, POST, PUT, và DELETE để thực hiện các thao tác CRUD. Ở đây mình sẽ tạo các phương thức GET, POST cho resource v1/users. Method type: Chọn loại phương thức HTTP mà bạn muốn tạo. Ví dụ, nếu bạn muốn tạo phương thức GET, hãy chọn GET từ danh sách. Proxy integration: Bật tùy chọn này để sử dụng tích hợp proxy. Integration type: Chọn loại tích hợp cho phương thức. Đối với trường hợp này, bạn sẽ chọn Lambda Function để tích hợp với Lambda function. Lambda Function: Chọn tên Lambda function mà bạn đã tạo ở bước trước, ví dụ UserService. Điều này sẽ liên kết phương thức HTTP với Lambda function để xử lý các yêu cầu. Các bạn có thể chọn Lambda Function cho tất cả các phương thức CRUD. Các phần còn lại bạn có thể để mặc định. Nhấn Create Method để hoàn tất việc tạo phương thức. Ta sẽ tạo thêm resource v1/users/{userID} để lấy thông tin chi tiết của một người dùng cụ thể. Tương tự như trên, bạn có thể tạo resource v1/users/{userID} bằng cách chọn Create Resource, nhập path là /v1/users/ và nhập tên resource là {userID}.\nĐây là các phương thức mà bạn sẽ tạo cho resource v1/users và v1/users/{userID}:\nGET /v1/users: Lấy danh sách tất cả người dùng. POST /v1/users: Tạo một người dùng mới. GET /v1/users/{userID}: Lấy thông tin chi tiết của một người dùng cụ thể. PUT /v1/users/{userID}: Cập nhật thông tin của một người dùng cụ thể. DELETE /v1/users/{userID}: Xóa một người dùng cụ thể. Deploy API Sau khi đã tạo các resource và phương thức cho API, bạn cần deploy API để có thể sử dụng được. Việc deploy sẽ tạo ra một endpoint mà bạn có thể gọi từ bên ngoài. Chọn Deploy API: Nhấn nút \u0026ldquo;Deploy API\u0026rdquo; trong trang quản lý API. Chọn Deployment stage: Chọn hoặc tạo một stage để deploy API. Bạn có thể tạo một stage mới với tên là dev hoặc sử dụng stage mặc định. Điền thông tin stage: Nhập tên stage là dev và nhấn Deploy để hoàn tất việc deploy API. Sau khi deploy, bạn sẽ nhận được một URL endpoint cho API. Đây là địa chỉ mà bạn có thể sử dụng để gọi các phương thức của API. Kiểm tra API Trước khi kiểm tra API, bạn cần đảm bảo rằng Lambda function đã được cấu hình đúng và có quyền truy cập vào DynamoDB. Bạn có thể kiểm tra quyền IAM của Lambda function để đảm bảo nó có quyền đọc và ghi vào bảng DynamoDB Users.\nQuay lại Lambda function tab \u0026ldquo;Configuration\u0026rdquo;, chọn tab \u0026ldquo;Permissions\u0026rdquo; và cuộn xuống phần \u0026ldquo;resource-based policy\u0026rdquo;. Ở đây bạn sẽ thấy các quyền mà Lambda function đã được cấp tương ứng với các methods mà bạn đã tạo trong API Gateway. Bạn có thể kiểm tra API bằng cách sử dụng Postman hoặc curl để gửi các yêu cầu đến các endpoint mà bạn đã tạo. Ví dụ, thêm một người dùng mới bằng cách gửi một yêu cầu POST với dữ liệu người dùng trong body.\n{ \u0026#34;userID\u0026#34;: \u0026#34;12345\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john.doe@example.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;123 Main St\u0026#34; } Hoặc để lấy danh sách tất cả người dùng, bạn có thể gửi một yêu cầu GET đến URL endpoint /v1/users. Vậy chúng ta đã hoàn thành việc tạo API Gateway và cấu hình các phương thức để tương tác với Lambda function và DynamoDB. Bây giờ bạn có thể sử dụng API này để thực hiện các thao tác CRUD trên bảng Users trong DynamoDB thông qua Lambda function UserService.\n"
},
{
	"uri": "http://localhost:1313/internworkshop/vi/3-deploycodebuild/",
	"title": "Triển khai trên CodeBuild",
	"tags": [],
	"description": "",
	"content": "Ở Bước này ta sẽ triển khai mã nguồn của mình lên AWS CodeBuild. CodeBuild là một dịch vụ biên dịch mã nguồn tự động, giúp bạn xây dựng và kiểm thử ứng dụng mà không cần quản lý máy chủ. Trong quá trình này, bạn sẽ tạo một repository trên GitHub để lưu trữ mã nguồn, sau đó tạo một dự án CodeBuild để biên dịch mã nguồn của bạn. Dự án này sẽ sử dụng tệp cấu hình buildspec.yml để xác định các bước cần thực hiện trong quá trình biên dịch.\nNội dung Tạo GitHub Repository Tạo CodeBuild Project "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/4-monitoring/",
	"title": "Thực hiện giám sát và tạo cảnh báo",
	"tags": [],
	"description": "",
	"content": "Ở bước này, chúng ta sẽ thực hiện các bước để giám sát và tạo cảnh báo cho API Gateway. Việc này sẽ giúp chúng ta theo dõi hiệu suất và hoạt động của API, đồng thời nhận được thông báo khi có sự cố xảy ra.\nNội dung: Cấu hình API Gateway Cấu hình Lambda "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/5-deploycodepipeline/",
	"title": "Triển khai CodePipeline",
	"tags": [],
	"description": "",
	"content": "Ở bước này, chúng ta sẽ triển khai CodePipeline để tự động hóa quá trình triển khai mã nguồn. CodePipeline sẽ giúp chúng ta tự động hóa các bước từ việc lấy mã nguồn, xây dựng, kiểm tra đến triển khai ứng dụng.\nTạo CodePipeline Truy cập vào AWS Management Console và mở dịch vụ CodePipeline. Chọn Create pipeline để tạo một pipeline mới. Trong phần Choose creation option, chọn Build custom pipeline. Nhập tên cho pipeline, ví dụ: UserServicePipeline.\nExecution mode: chọn \u0026ldquo;Queueue\u0026rdquo; để cho phép các thay đổi được xếp hàng và xử lý tuần tự.\nChọn New service role để tạo một IAM Role mới cho CodePipeline hoặc chọn Existing service role nếu bạn đã có IAM Role phù hợp. Ở đây, chúng ta sẽ chọn New service role để CodePipeline có thể tự động quản lý các dịch vụ AWS khác. Với tên là CodePipelineServiceRole. Chọn Next để tiếp tục.\nChọn mã nguồn Trong phần Source provider, chọn GitHub(via OAuth App). Kết nối với tài khoản GitHub của bạn bằng cách chọn Connect to GitHub. Ở đây, bạn sẽ cần đăng nhập vào GitHub và cấp quyền cho AWS CodePipeline truy cập vào repository của bạn. Sau khi kết nối thành công, bạn sẽ thấy danh sách các repository của mình. Chọn repository chứa mã nguồn của bạn, ví dụ: UserService. Chọn nhánh mà bạn muốn theo dõi, ví dụ: main. Chọn Next để tiếp tục. Chọn dịch vụ xây dựng Trong phần Build provider, chọn Other build providers và chọn AWS CodeBuild.\nProject name: Nhập tên cho dự án CodeBuild đã tạo, ví dụ: UserServiceBuild.\nChọn Next để tiếp tục. Ở phần Test (nếu có), bạn có thể bỏ qua bước này nếu không cần kiểm tra tự động. Nếu cần, bạn có thể cấu hình các bước kiểm tra tại đây.\nChọn Next để tiếp tục.\nTương tự, trong phần Deploy, bạn có thể cấu hình các bước triển khai nếu cần. Nếu không cần triển khai tự động, bạn có thể bỏ qua bước này.\nChọn Next để tiếp tục.\nXem lại và tạo pipeline Trong phần Review, kiểm tra lại các thông tin đã cấu hình. Nếu mọi thứ đúng, chọn Create pipeline để tạo pipeline. Sau khi pipeline được tạo, bạn sẽ thấy giao diện chính của CodePipeline với các bước đã cấu hình. Sau khi pipeline được tạo, CodePipeline sẽ tự động bắt đầu quá trình triển khai. Bạn có thể theo dõi tiến trình của pipeline trong giao diện CodePipeline. Pipeline sẽ tự động lấy mã nguồn từ GitHub, xây dựng ứng dụng bằng CodeBuild và triển khai ứng dụng nếu bạn đã cấu hình bước triển khai.\nVì ở đây mình chỉ cấu hình bước lấy mã nguồn và xây dựng, nên pipeline sẽ chỉ thực hiện các bước này. Bạn có thể thêm các bước kiểm tra và triển khai nếu cần thiết.\nPipeline sẽ tự động bắt đầu quá trình triển khai khi có thay đổi mã nguồn được đẩy lên nhánh đã cấu hình.\nBạn có thể theo dõi tiến trình của pipeline trong giao diện CodePipeline. Nếu có lỗi xảy ra, bạn sẽ thấy thông báo lỗi và có thể kiểm tra chi tiết trong các bước của pipeline.\nĐây là cách chúng ta triển khai CodePipeline để tự động hóa quá trình triển khai mã nguồn. Với CodePipeline, chúng ta có thể dễ dàng quản lý và theo dõi quá trình phát triển ứng dụng, từ việc lấy mã nguồn, xây dựng, kiểm tra đến triển khai ứng dụng một cách tự động và hiệu quả.\n"
},
{
	"uri": "http://localhost:1313/internworkshop/vi/6-cleanup/",
	"title": "Dọn dẹp tài nguyên  ",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ tiến hành các bước sau để xóa các tài nguyên chúng ta đã tạo trong bài thực hành này.\nXóa CodePipeline Truy cập vào giao diện quản trị dịch vụ CodePipeline Chọn pipeline mà bạn muốn xóa. Nhấn Delete Pipeline để xóa pipeline. Xác nhận việc xóa bằng cách nhập tên pipeline và Nhấn Delete. Xóa S3 Bucket Vì Pipeline tự động tạo ra một bucket S3 để lưu trữ các artifacts, nên chúng ta cần xóa bucket này sau khi đã xóa pipeline.\nTruy cập vào giao diện quản trị dịch vụ S3 Chọn bucket mà bạn đã tạo trong bài lab này. Trước tiên, bạn cần đảm bảo rằng bucket S3 không còn chứa bất kỳ dữ liệu nào. Bạn có thể xóa các tệp trong bucket hoặc xóa toàn bộ bucket. Nhấn Empty để xóa tất cả các tệp trong bucket. Xác nhận việc xóa bằng cách nhập tên bucket và Nhấn Empty. Tiếp theo nhấn Delete để xóa bucket. Xác nhận việc xóa bằng cách nhập tên bucket và Nhấn Delete. Xóa CodeBuild Truy cập vào giao diện quản trị dịch vụ CodeBuild Chọn dự án CodeBuild mà bạn muốn xóa. Ở phần Actions, Nhấn Delete. Xác nhận việc xóa bằng cách nhập tên dự án và Nhấn Delete. Xóa IAM Role Truy cập vào giao diện quản trị dịch vụ IAM Chọn Roles từ menu bên trái. Chọn IAM Role mà bạn đã tạo trong bài lab này để xóa. Nhấn Delete để xóa IAM Role. Xác nhận việc xóa bằng cách nhập tên IAM Role và Nhấn Delete. Xóa Lambda Function Truy cập vào giao diện quản trị dịch vụ Lambda Chọn hàm Lambda mà bạn đã tạo trong bài lab này. Nhấn Actions và chọn Delete. Xác nhận việc xóa bằng cách nhập confirm và Nhấn Delete. Xóa API Gateway Truy cập vào giao diện quản trị dịch vụ API Gateway Chọn API mà bạn đã tạo trong bài lab này. Nhấn Delete ở góc trên bên phải. Xác nhận việc xóa bằng cách nhập confirm và Nhấn Delete. Xóa DynamoDB Table Truy cập vào giao diện quản trị dịch vụ DynamoDB Chọn bảng mà bạn đã tạo trong bài lab này. Nhấn Delete để xóa bảng. Xác nhận việc xóa bằng cách nhập confirm và Nhấn Delete. "
},
{
	"uri": "http://localhost:1313/internworkshop/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/internworkshop/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]